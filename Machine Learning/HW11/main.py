# %%
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import glob
import os

# 1. Load the horse images and bird image
# Assuming 'horses' directory contains horse images named 'horse001.png' to 'horse327.png'
horse_images_path: list[str] = sorted(glob.glob('horses/*.png'))
bird_image_path = 'bird.png'

horses: list[np.ndarray] | np.ndarray = []
for img_path in horse_images_path:
    img: Image.Image = Image.open(img_path).convert('L')
    # Normalize pixel values to [0,1]
    img_array = np.asarray(img, dtype=float) / 255.0
    horses.append(img_array.flatten())
horses = np.array(horses)  # shape: (327, 128*128)

bird_img: Image.Image = Image.open(bird_image_path).convert('L')
bird_array = np.asarray(bird_img, dtype=float) / 255.0
bird_vector:np.ndarray = bird_array.flatten()  # Flatten bird image

# 2. Compute the mean of the horse dataset
mean_horse:np.ndarray = np.mean(horses, axis=0)

# 3. Center the horse data by subtracting the mean
horses_centered = horses - mean_horse

# 4. Perform SVD on the horse images (PCA)
U, S, VT = np.linalg.svd(horses_centered, full_matrices=False)
V = VT.T  # Principal components (eigenvectors)

# a) Discard the two largest singular values and plot the remaining singular values
# discard the first two largest singular values
remaining_singular_values:np.ndarray = S[2:]
plt.figure(figsize=(6, 4))
plt.plot(remaining_singular_values, marker='o')
plt.title('Remaining Singular Values (Sorted in Decreasing Order)')
plt.xlabel('Index')
plt.ylabel('Singular Value')
plt.savefig('remaining_singular_values.png')
plt.show()

# b) Project the horses onto the first two principal components and plot
pcs:np.ndarray = V[:, :2]  # first two principal components
horse_projections:np.ndarray = horses_centered.dot(pcs)  # shape: (327, 2)

plt.figure(figsize=(6, 4))
plt.scatter(horse_projections[:, 0],
            horse_projections[:, 1], c='black', label='Horses')
plt.title('Projection of Horses onto First 2 PCs')
plt.xlabel('PC1')
plt.ylabel('PC2')
plt.legend()
plt.savefig('horse_projections.png')  # Save plot
plt.show()

# c) On the same graph, plot the horse projections in black and bird projection in red 'x'
bird_centered = bird_vector - mean_horse
bird_projection:np.ndarray = bird_centered.dot(pcs)

plt.figure(figsize=(6, 4))
plt.scatter(horse_projections[:, 0],
            horse_projections[:, 1], c='black', label='Horses')
plt.scatter(bird_projection[0], bird_projection[1],
            c='red', marker='x', s=100, label='Bird')
plt.title('Horse Projections and Bird Projection on First 2 PCs')
plt.xlabel('PC1')
plt.ylabel('PC2')
plt.legend()
plt.savefig('horse_bird_projection.png')  # Save plot
plt.show()

# d) Using the model, display the image 'horse070.png' and its binary reconstruction using 32 PCs (threshold 0.5)
# Find the horse070 image vector
horse070_img: Image.Image = Image.open('horses/horse070.png').convert('L')
horse070_array = np.asarray(horse070_img, dtype=float) / 255.0
horse070_vector:np.ndarray = horse070_array.flatten()

# Center the horse070 image
horse070_centered = horse070_vector - mean_horse

# Reconstruct using first 32 PCs
num_pcs = 32
pcs_32:np.ndarray = V[:, :num_pcs]
scores_32:np.ndarray = horse070_centered.dot(pcs_32)
horse070_reconstructed:np.ndarray = mean_horse + scores_32.dot(pcs_32.T)
horse070_reconstructed_binary:np.ndarray = (
    horse070_reconstructed > 0.5).astype(float)

# Display the original and reconstructed binary images
fig, axs = plt.subplots(1, 2, figsize=(8, 4))
axs[0].imshow(horse070_array.reshape(128, 128), cmap='gray')
axs[0].set_title('Original Horse070')
axs[0].axis('off')
axs[1].imshow(horse070_reconstructed_binary.reshape(128, 128), cmap='gray')
axs[1].set_title('Binary Reconstruction (32 PCs)')
axs[1].axis('off')
plt.savefig('horse070_reconstruction.png')  # Save figure
plt.show()

# e) Using the same model, display the bird image and its binary reconstruction using 32 PCs
bird_reconstructed:np.ndarray = mean_horse + (bird_centered.dot(pcs_32)).dot(pcs_32.T)
bird_reconstructed_binary:np.ndarray = (bird_reconstructed > 0.5).astype(float)

# Display the original and reconstructed binary bird images
fig, axs = plt.subplots(1, 2, figsize=(8, 4))
axs[0].imshow(bird_array.reshape(128, 128), cmap='gray')
axs[0].set_title('Original Bird')
axs[0].axis('off')
axs[1].imshow(bird_reconstructed_binary.reshape(128, 128), cmap='gray')
axs[1].set_title('Binary Reconstruction (32 PCs)')
axs[1].axis('off')
plt.savefig('bird_reconstruction.png')  # Save figure
plt.show()

# f) Compute the distances of the horses and the bird to the plane generated by the 32 largest PCs.
# The plane generated by the 32 largest PCs can be approximated by reconstructing each image using 32 PCs.
horse_reconstructions_32 = mean_horse + \
    (horses_centered.dot(pcs_32)).dot(pcs_32.T)
distances_horses = np.linalg.norm(
    horses_centered - (horse_reconstructions_32 - mean_horse), axis=1)
distance_bird = np.linalg.norm(
    bird_centered - (bird_reconstructed - mean_horse))

# On the same graph, plot the computed distances vs the coordinates of the projections on the second PC
plt.figure(figsize=(6, 4))
plt.scatter(horse_projections[:, 1],
            distances_horses, c='black', label='Horses')
plt.scatter(bird_projection[1], distance_bird,
            c='red', marker='x', s=100, label='Bird')
plt.title('Distances vs. Projection on 2nd PC')
plt.xlabel('Projection on PC2')
plt.ylabel('Distance to 32-PC Plane')
plt.legend()
plt.savefig('distances_vs_pc2.png')  # Save plot
plt.show()

# g) Plot the histogram of the distances obtained at f) for the horses
plt.figure(figsize=(6, 4))
plt.hist(distances_horses, bins=20, color='black')
plt.title('Histogram of Distances to 32-PC Plane for Horses')
plt.xlabel('Distance')
plt.ylabel('Frequency')
plt.savefig('hist_distances_horses.png')  # Save plot
plt.show()

# %%
